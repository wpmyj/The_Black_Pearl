
#include "bsp_adc.h"
#include "bsp_usart.h"

#define ADC1_DR_Address    ((u32)0x40012400+0x4c)

__IO uint16_t ADC_ConvertedValue[4];



extern u8 flag_adc_mask ;


#define ADC_SAMPLE_NUM  200      //一秒采样多少点
static __IO u32 COUNT = ADC_SAMPLE_NUM;
__IO uint32_t ADC_SampleValue[4] = {0,0,0,0};
// 用于保存转换计算后的电压值
float ADC_ConvertedValueLocal[4] = {2.5,0,0,0 };
//__IO u16 ADC_ConvertedValueLocal;

/**
  * @brief  使能ADC1和DMA1的时钟，初始化PC.0
  * @param  无
  * @retval 无
  */
static void ADC1_GPIO_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable DMA clock */
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

    /* Enable ADC1 and GPIOC clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC |RCC_APB2Periph_GPIOB,  ENABLE);


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOC, &GPIO_InitStructure);				// PC1,输入时不用设置速率

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOC, &GPIO_InitStructure);				// PC2,输入时不用设置速率

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOC, &GPIO_InitStructure);				// PC3,输入时不用设置速率

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, &GPIO_InitStructure);				// PB0,输入时不用设置速率


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    GPIO_ResetBits(GPIOB,GPIO_Pin_1); // 使能端，低电平 对地产生电压

}

/**
  * @brief  配置ADC1的工作模式为MDA模式
  * @param  无
  * @retval 无
  */
static void ADC1_Mode_Config(void)
{
    DMA_InitTypeDef DMA_InitStructure;
    ADC_InitTypeDef ADC_InitStructure;

    /* DMA channel1 configuration */
    DMA_DeInit(DMA1_Channel1);

    DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;	 			//ADC地址
    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;	//内存地址
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_BufferSize = 4;
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	//外设地址固定
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  				//内存地址固定
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	//半字
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;										//循环传输
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    DMA_Init(DMA1_Channel1, &DMA_InitStructure);

    /* Enable DMA channel1 */
    DMA_Cmd(DMA1_Channel1, ENABLE);

    /* ADC1 configuration */
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;			//独立ADC模式
    ADC_InitStructure.ADC_ScanConvMode = ENABLE ; 	 				//禁止扫描模式，扫描模式用于多通道采集
    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;			//开启连续转换模式，即不停地进行ADC转换
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	//不使用外部触发转换
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; 	//采集数据右对齐
    ADC_InitStructure.ADC_NbrOfChannel = 4;	 								//要转换的通道数目1
    ADC_Init(ADC1, &ADC_InitStructure);

    /*配置ADC时钟，为PCLK2的8分频，即9MHz*/
    RCC_ADCCLKConfig(RCC_PCLK2_Div8);
    /*配置ADC1的通道11为55.	5个采样周期，序列为1 */
    ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 2, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 3, ADC_SampleTime_55Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_8,  4, ADC_SampleTime_55Cycles5);

    /* Enable ADC1 DMA */
    ADC_DMACmd(ADC1, ENABLE);

    /* Enable ADC1 */
    ADC_Cmd(ADC1, ENABLE);

    /*复位校准寄存器 */
    ADC_ResetCalibration(ADC1);
    /*等待校准寄存器复位完成 */
    while(ADC_GetResetCalibrationStatus(ADC1));

    /* ADC校准 */
    ADC_StartCalibration(ADC1);
    /* 等待校准完成*/
    while(ADC_GetCalibrationStatus(ADC1));

    /* 由于没有采用外部触发，所以使用软件触发ADC转换 */
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
}

/**
  * @brief  ADC1初始化
  * @param  无
  * @retval 无
  */
void ADC1_Init(void)
{
    ADC1_GPIO_Config();
    ADC1_Mode_Config();
}



void ADC1_GPIO_STOP_MODE(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    /* Enable ADC1 and GPIOC clock */
    RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOC |RCC_APB2Periph_GPIOB,  ENABLE);


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 |GPIO_Pin_2 |GPIO_Pin_3;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOC, &GPIO_InitStructure);				// PC0,输入时不用设置速率

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOB, &GPIO_InitStructure);				// PC0,输入时不用设置速率


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    GPIO_SetBits(GPIOB,GPIO_Pin_1);

}


void 	ADC_Get_Data(void)
{



    if(flag_adc_mask > 0)
    {
        if(flag_adc_mask++ == 20)
            flag_adc_mask = 0;

    } else
    {

        if (COUNT != 0)
        {
            COUNT--;
            ADC_SampleValue[0] += ADC_ConvertedValue[0];
            ADC_SampleValue[1] += ADC_ConvertedValue[1];
            ADC_SampleValue[2] += ADC_ConvertedValue[2];
            ADC_SampleValue[3] += ADC_ConvertedValue[3];

        }
        else
        {
            COUNT = ADC_SAMPLE_NUM;
            ADC_ConvertedValueLocal[0] =((float) ADC_SampleValue[0])/ADC_SAMPLE_NUM/4096*3.3; // 读取转换的AD值
            ADC_ConvertedValueLocal[1] =((float) ADC_SampleValue[1])/ADC_SAMPLE_NUM/4096*3.3; // 读取转换的AD值
            ADC_ConvertedValueLocal[2] =((float) ADC_SampleValue[2])/ADC_SAMPLE_NUM/4096*3.3; // 读取转换的AD值
            ADC_ConvertedValueLocal[3] =((float) ADC_SampleValue[3])/ADC_SAMPLE_NUM/4096*3.3; // 读取转换的AD值

            //			printf("\r\n ADC1_10 = %f V\r\n ",ADC_ConvertedValueLocal[0]);
            //			printf("\r\n ADC1_11 = %f V \r\n",ADC_ConvertedValueLocal[1]);
            //			printf("\r\n ADC1_12 = %f V \r\n",ADC_ConvertedValueLocal[2]);
            //			printf(" \r\nADC1_13 = %f V \r\n",ADC_ConvertedValueLocal[3]);


            ADC_SampleValue[0] = 0;
            ADC_SampleValue[1] = 0;
            ADC_SampleValue[2] = 0;
            ADC_SampleValue[3] = 0;
        }
    }

}


/*********************************************END OF FILE**********************/
